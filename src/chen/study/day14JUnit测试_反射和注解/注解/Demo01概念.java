package chen.study.day14JUnit测试_反射和注解.注解;
/*
    注解的概念：也是说明程序的，不过是给计算机看的
        注释：用于文字描述程序的，给程序员看的

    定义：   从JDK5开始,Java增加对元数据的支持，也就是注解(Annotation)，注解与注释是有一定区别的，
            可以把注解理解为代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，
            并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息

    作用分类：
            1.编写文档：通过代码里标识的元数据来生成文档【生成doc文档】
            2.代码分析：通过代码里标识的元数据对代码进行分析【反射】
            3.编译检查：通过代码里标识的元数据能够让编译器实现基本的编译检查【Override】
    学习目标：
            1.JDK里预定义的一些注解
                （1）@Override:用来检测被该注解标注的方法是否是继承自父类/接口的
                （2）@Deprecated：该注解标注的内容已过时
                （3）@SuppressWarnings：压制警告
                        一般传递参数all @SuppressWarnings("all")//压制所有警告
            2.自定义注解
                格式：
                    元注解
                    public @interface 注解名称

                注解本质上就是一个接口，默认继承java.lang.annotation.Annotation{}

                属性：接口中的抽象方法
                    要求：
                        1.属性的返回值类型：（1）基本数据类型（2）String（3）枚举（4）注解（5）以上类型的数组
                        2.定义了属性，在使用时需要给属性赋值
                            如果只有一个属性需要赋值，而且属性名是value那么在赋值时只用写值就好

                元注解：用于描述注解的注解
                    @Target:描述注解能够作用的位置
                        ElementType的取值：（1）TYPE：表示可以作用于类上
                                          （2）METHOD：表示可以做用于方法上
                                          （3）FIELD：表示可以作用于成员变量上
                    @Retention：描述注解被保留的阶段：SOURCE，CLASS，RUNTIME三个阶段
                        @Retention(RetentionPolicy.RUNTIME)
                                    表示当前这个注解注解的那个类时，
                                    那个类在运行期时，jvm虚拟机会读取到这个注解
                    @Documented：描述注解是否被抽取到API文档中
                    @Inherited：描述注解是否被子类继承

            3.在程序中使用注解
                (1)获取注解定义的对象
                (2)获取指定的注解
                        getAnnotation(Class)
                (3)调用注释中的抽象方法获取配置的属性值，其实就是内存中生成一个抽象方法接口的实现类

    小结：
        我们以后会更多的使用注解而不是自定义注解
        注解给谁用？编译器和解析程序
        注解并不是程序的一部分
 */
public class Demo01概念 {
}
